# Coze 官方会话隔离实现指南

本文档基于 Coze 官方文档整理,详细说明如何使用 OAuth JWT 实现会话隔离功能。

---

## 目录
- [什么是会话隔离](#什么是会话隔离)
- [为什么需要会话隔离](#为什么需要会话隔离)
- [官方实现方案](#官方实现方案)
- [实现步骤详解](#实现步骤详解)
- [常见问题与解决方案](#常见问题与解决方案)
- [完整示例代码](#完整示例代码)

---

## 什么是会话隔离

**会话隔离**是指在多用户系统中,确保每个用户的对话上下文完全独立,互不干扰的机制。

### 场景示例

开发者搭建了一个智能体,并通过 Chat SDK 的方式嵌入到自建网站中,供网站的访问者使用。

**未设置会话隔离的问题**:
- 网站访问者 A 和 B 在智能体对话框中可以查看到其他用户和智能体的对话记录
- 用户 A 的上下文信息会被用户 B 看到
- 不同用户的对话混在一起,造成隐私泄露和体验问题

**设置会话隔离后**:
- 用户 A 和用户 B 拥有完全独立的对话空间
- 用户 A 无法看到用户 B 的对话记录
- 每个用户都有独立的上下文记忆

---

## 为什么需要会话隔离

### 核心需求

1. **隐私保护**: 防止用户之间的对话记录泄露
2. **上下文独立**: 确保每个用户的对话上下文不混淆
3. **多用户支持**: 支持多个用户同时使用同一个智能体
4. **会话记忆**: 每个用户都能获得个性化的对话体验

### 适用场景

- ✅ 多用户 SaaS 系统
- ✅ 客服系统 (每个客户独立会话)
- ✅ 教育平台 (每个学生独立学习记录)
- ✅ 企业内部应用 (员工之间会话隔离)
- ✅ 公开网站嵌入智能体

---

## 官方实现方案

### 核心要求

> **官方说明**: 仅 OAuth 的 JWT 鉴权方式可实现会话隔离。但必须在 payload 中添加 session_name 字段。

### 实现原理

会话隔离需要在**两个地方**都添加 `session_name`:

1. **JWT Token 的 Payload 中**: 在签署 JWT 时添加 `session_name` 字段
2. **API 请求的 Payload 中**: 在调用 Coze API 时,在请求体中添加 `session_name` 字段

**两处缺一不可!**

---

## 实现步骤详解

### 步骤 1: 获取业务侧的用户 UID

从网站的账号系统中,获取网站用户的唯一标识符 (UID)。

**示例**:
- 用户 A 的 UID: `USER_A`
- 用户 B 的 UID: `USER_B`

**实现建议**:
```javascript
// 前端: 生成或获取用户唯一标识
function getUserId() {
    // 方案1: 从登录系统获取
    return localStorage.getItem('user_id');

    // 方案2: 为匿名用户生成临时ID (存储在 sessionStorage)
    let sessionId = sessionStorage.getItem('session_id');
    if (!sessionId) {
        sessionId = 'session_' + Math.random().toString(36).substr(2, 16);
        sessionStorage.setItem('session_id', sessionId);
    }
    return sessionId;
}
```

---

### 步骤 2: 获取 JWT Token

参考 [OAuth JWT 授权文档](https://www.coze.cn/docs/developer_guides/oauth_jwt)实现 OAuth JWT 授权,并分别为用户 A 和 B 申请 JWT Token。

#### 2.1 JWT Payload 格式

在**步骤3: 签署 JWT** 中,Payload 中必须添加 `session_name` 字段,并将其设置为网站用户的 UID。

**标准 JWT Payload 示例**:

```json
{
    "iss": "310000000002",           // OAuth 应用的 ID
    "aud": "api.coze.cn",            // 扣子 API 的 Endpoint (国内版: api.coze.cn, 国际版: api.coze.com)
    "iat": 1516239022,               // JWT 开始生效的时间,秒级时间戳
    "exp": 1516259022,               // JWT 过期时间,秒级时间戳
    "jti": "fhjashjgkhalskj",        // 随机字符串,防止重放攻击
    "session_name": "user_2222",     // ✅ 关键: 用户在业务侧的 UID
    "session_context": {             // 可选: 会话上下文信息
        "device_info": {
            "device_id": "1234567890" // IoT 等硬件设备的唯一标识 ID
        }
    }
}
```

**字段说明**:

| 字段 | 必填 | 说明 |
|------|------|------|
| `iss` | ✅ | OAuth 应用的 Client ID |
| `aud` | ✅ | Coze API 地址 (国内: api.coze.cn, 国际: api.coze.com) |
| `iat` | ✅ | JWT 签发时间 (秒级时间戳) |
| `exp` | ✅ | JWT 过期时间 (秒级时间戳,最长 24 小时) |
| `jti` | ✅ | 唯一标识符,防止重放攻击 (UUID) |
| `session_name` | ✅ | **会话隔离关键字段**: 用户唯一标识 |
| `session_context` | ❌ | 可选: 额外的会话上下文信息 |

#### 2.2 签署 JWT

使用 RS256 算法签署 JWT:

**Python 实现示例**:

```python
import jwt
import time
import uuid

def create_jwt_token(client_id, private_key, public_key_id, session_name, ttl=3600):
    """
    创建 JWT Token

    Args:
        client_id: OAuth 应用 ID
        private_key: 私钥内容 (PEM 格式)
        public_key_id: 公钥 ID
        session_name: 用户唯一标识 (用于会话隔离)
        ttl: Token 有效期 (秒),默认 3600,最长 86400

    Returns:
        JWT Token 字符串
    """
    now = int(time.time())

    # JWT Payload
    payload = {
        "iss": client_id,
        "aud": "api.coze.cn",  # 国际版改为 api.coze.com
        "iat": now,
        "exp": now + ttl,
        "jti": str(uuid.uuid4()),
        "session_name": session_name  # ✅ 关键: 添加 session_name
    }

    # JWT Headers
    headers = {
        "kid": public_key_id,
        "alg": "RS256",
        "typ": "JWT"
    }

    # 签署 JWT
    jwt_token = jwt.encode(
        payload,
        private_key,
        algorithm="RS256",
        headers=headers
    )

    return jwt_token
```

#### 2.3 获取 Access Token

使用签署好的 JWT Token 向 Coze OAuth 服务器请求 Access Token:

```python
import httpx

def get_access_token(jwt_token, api_base="https://api.coze.cn"):
    """
    使用 JWT 获取 Access Token

    Args:
        jwt_token: 签署好的 JWT Token
        api_base: Coze API 地址

    Returns:
        Access Token 字符串
    """
    url = f"{api_base}/api/permission/oauth2/token"

    payload = {
        "grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
        "assertion": jwt_token,
        "duration_seconds": 3600  # Token 有效期
    }

    headers = {
        "Content-Type": "application/json"
    }

    response = httpx.post(url, json=payload, headers=headers)

    if response.status_code == 200:
        data = response.json()
        return data["access_token"]
    else:
        raise Exception(f"获取 Access Token 失败: {response.text}")
```

**示例返回值**:

```json
{
    "access_token": "czs_RQOhsc7vmUzK4bNgb7hn4wqOgRBYAO6xvpFHNbnl6RiQJX3cSXSguIahiuhwfw****",
    "expires_in": 3600,
    "token_type": "Bearer"
}
```

**不同用户的 Token 示例**:

```python
# 用户 A 的 JWT Token
jwt_token_a = create_jwt_token(
    client_id="310000000002",
    private_key=private_key_content,
    public_key_id="key_id_123",
    session_name="USER_A"  # ← 用户 A 的唯一标识
)
access_token_a = get_access_token(jwt_token_a)
# 结果: czs_RQOhsc7vmUzK4bNgb7hn4wqOgRBYAO6xvpFHNbnl6RiQJX3cSXSguIahiuhwfw****

# 用户 B 的 JWT Token
jwt_token_b = create_jwt_token(
    client_id="310000000002",
    private_key=private_key_content,
    public_key_id="key_id_123",
    session_name="USER_B"  # ← 用户 B 的唯一标识
)
access_token_b = get_access_token(jwt_token_b)
# 结果: czs_DJWOEF7vmUzK4bNgb7hn4wqOgRBYAO6xvpFHNbnl6RiQJX3cSXSguIhFDzgy****
```

---

### 步骤 3: 在 API 请求中添加 session_name

**关键**: 除了在 JWT 中添加 `session_name`,还必须在调用 Coze API 时,在请求体的**顶层字段**中添加 `session_name`。

#### 3.1 使用 Workflow Chat API

**API 请求示例**:

```python
import httpx

def chat_with_workflow(access_token, workflow_id, app_id, session_name, user_message):
    """
    调用 Workflow Chat API

    Args:
        access_token: 用户的 Access Token (已包含 session_name)
        workflow_id: 工作流 ID
        app_id: 应用 ID
        session_name: 用户唯一标识 (必须与 JWT 中的一致)
        user_message: 用户消息

    Returns:
        AI 回复内容
    """
    url = "https://api.coze.cn/v1/workflows/chat"

    # ✅ 关键: payload 中必须包含 session_name 字段 (顶层字段)
    payload = {
        "workflow_id": workflow_id,
        "app_id": app_id,
        "session_name": session_name,  # ← 关键: 必须添加!
        "parameters": {
            "USER_INPUT": user_message
        },
        "additional_messages": [
            {
                "content": user_message,
                "content_type": "text",
                "role": "user",
                "type": "question"
            }
        ]
    }

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }

    response = httpx.post(url, json=payload, headers=headers)
    return response.json()
```

**完整调用示例**:

```python
# 用户 A 发送消息
response_a = chat_with_workflow(
    access_token=access_token_a,
    workflow_id="7568811304438710279",
    app_id="7568402281331949575",
    session_name="USER_A",  # ← 用户 A 的标识
    user_message="你好,我是用户A"
)

# 用户 B 发送消息
response_b = chat_with_workflow(
    access_token=access_token_b,
    workflow_id="7568811304438710279",
    app_id="7568402281331949575",
    session_name="USER_B",  # ← 用户 B 的标识
    user_message="你好,我是用户B"
)
```

#### 3.2 使用 Chat SDK

参考 [安装并使用 Chat SDK](https://www.coze.cn/docs/developer_guides/chat_sdk) 接入 Chat SDK 时,在**步骤四:配置聊天框**中,`auth` 的 `token` 参数设置为网站用户对应的 Token。

**前端代码示例**:

```javascript
import CozeWebSDK from '@coze/web-sdk';

// 获取用户 UID
const userId = getUserId(); // 从业务系统获取,如 "USER_A"

// 向后端请求该用户的 Access Token
const accessToken = await fetch('/api/get-token', {
    method: 'POST',
    body: JSON.stringify({ user_id: userId })
}).then(r => r.json()).then(data => data.access_token);

// 初始化 Chat SDK
const client = new CozeWebSDK.ChatClient({
    config: {
        bot_id: 'your_bot_id',
    },
    auth: {
        type: 'token',
        token: accessToken  // ← 使用该用户的 Access Token
    },
});

// 发送消息
client.sendMessage({
    content: '你好',
    content_type: 'text',
});
```

**关键点**:
- ✅ 确保用户 A 和用户 B 在和智能体对话时,分别使用的是自己的 JWT Token
- ✅ 前端每次初始化 SDK 时,都应该使用当前登录用户的 Token
- ✅ Token 过期后需要重新获取

---

### 步骤 4: 为每个用户创建独立的 Conversation

**官方建议**: 为了实现完整的会话隔离,建议为每个用户创建独立的 `conversation_id`。

#### 4.1 创建 Conversation

```python
import httpx

def create_conversation(access_token, api_base="https://api.coze.cn"):
    """
    为用户创建独立的 Conversation

    Args:
        access_token: 用户的 Access Token (包含 session_name)
        api_base: Coze API 地址

    Returns:
        conversation_id 字符串
    """
    url = f"{api_base}/v1/conversations"

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }

    response = httpx.post(url, headers=headers)

    if response.status_code == 200:
        data = response.json()
        return data["data"]["id"]
    else:
        raise Exception(f"创建 Conversation 失败: {response.text}")
```

#### 4.2 在聊天时使用 Conversation ID

```python
def chat_with_conversation(access_token, workflow_id, app_id, session_name,
                          conversation_id, user_message):
    """
    使用 Conversation ID 进行多轮对话
    """
    url = "https://api.coze.cn/v1/workflows/chat"

    payload = {
        "workflow_id": workflow_id,
        "app_id": app_id,
        "session_name": session_name,        # ✅ 会话隔离
        "conversation_id": conversation_id,  # ✅ 多轮对话
        "parameters": {
            "USER_INPUT": user_message
        },
        "additional_messages": [
            {
                "content": user_message,
                "content_type": "text",
                "role": "user",
                "type": "question"
            }
        ]
    }

    headers = {
        "Authorization": f"Bearer {access_token}",
        "Content-Type": "application/json"
    }

    response = httpx.post(url, json=payload, headers=headers)
    return response.json()
```

**完整流程示例**:

```python
# 用户 A 的完整对话流程
session_name_a = "USER_A"
access_token_a = get_access_token_for_user(session_name_a)
conversation_id_a = create_conversation(access_token_a)

# 第一轮对话
response1 = chat_with_conversation(
    access_token=access_token_a,
    workflow_id="xxx",
    app_id="xxx",
    session_name=session_name_a,
    conversation_id=conversation_id_a,
    user_message="你好,我叫张三"
)

# 第二轮对话 (使用同一个 conversation_id)
response2 = chat_with_conversation(
    access_token=access_token_a,
    workflow_id="xxx",
    app_id="xxx",
    session_name=session_name_a,
    conversation_id=conversation_id_a,  # ← 复用 conversation_id
    user_message="我叫什么名字?"
)
# 预期回复: "你叫张三"
```

---

## 常见问题与解决方案

### 问题 1: 会话隔离未生效,不同用户仍能看到彼此的对话

**根本原因** (根据官方分析):

对话流未实现完整的会话级资源隔离,具体包括:

1. **静态会话绑定与使用错误**
   - 应用对话流需绑定独立的静态会话(每个用户一个会话)
   - 但可能存在多个用户复用同一静态会话的情况,导致消息存储冲突

2. **长期记忆/知识库未按 session_name 隔离**
   - 长期记忆节点未启用「按会话隔离」,导致不同用户记忆数据共享
   - 知识库检索时未传入 `session_name` 作为筛选条件,全局数据泄露

3. **API 调用未指定独立 conversation_id**
   - 仅依赖 `session_name` 而未传递 `conversation_id`,导致对话上下文复用同一对话 ID

**解决方案**:

#### 方案 1: 确保双重添加 session_name

✅ **在 JWT Payload 中添加**:
```python
payload = {
    "iss": client_id,
    "aud": "api.coze.cn",
    "iat": now,
    "exp": now + 3600,
    "jti": str(uuid.uuid4()),
    "session_name": user_id  # ← JWT 中添加
}
```

✅ **在 API 请求 Payload 中添加**:
```python
api_payload = {
    "workflow_id": "xxx",
    "app_id": "xxx",
    "session_name": user_id,  # ← API 中也要添加
    "parameters": {...}
}
```

#### 方案 2: 为每个用户创建独立的 Conversation

```python
# 用户首次对话时创建 Conversation
if user_id not in conversation_cache:
    conversation_id = create_conversation(access_token)
    conversation_cache[user_id] = conversation_id

# 后续对话都使用该 conversation_id
api_payload = {
    "workflow_id": "xxx",
    "app_id": "xxx",
    "session_name": user_id,
    "conversation_id": conversation_cache[user_id],  # ← 添加独立的 conversation_id
    "parameters": {...}
}
```

#### 方案 3: 配置工作流的会话隔离设置

在 Coze 平台的工作流配置中:

1. **检查静态会话配置**:
   - 进入工作流编辑页面
   - 确保**未**使用静态会话名称
   - 或者确保静态会话名称与 `session_name` 一致

2. **配置长期记忆节点**:
   - 如果工作流中有"长期记忆"节点
   - 启用"按会话隔离"选项
   - 确保记忆数据按 `session_name` 存储

3. **配置知识库节点**:
   - 如果使用知识库检索
   - 在检索参数中添加 `session_name` 筛选
   - 或使用用户级别的知识库隔离

---

### 问题 2: Token 过期后如何处理?

**解决方案**: JWT OAuth 方式的 Token 不支持刷新,过期后需要重新生成。

```python
class TokenManager:
    def __init__(self):
        self.token_cache = {}  # {session_name: {token, expires_at}}

    def get_access_token(self, session_name):
        """获取 Access Token (带缓存)"""
        # 检查缓存
        if session_name in self.token_cache:
            cached = self.token_cache[session_name]
            if cached['expires_at'] > datetime.now():
                return cached['token']  # 使用缓存

        # 生成新 Token
        jwt_token = create_jwt_token(
            client_id=self.client_id,
            private_key=self.private_key,
            public_key_id=self.public_key_id,
            session_name=session_name
        )

        access_token = get_access_token(jwt_token)

        # 更新缓存
        self.token_cache[session_name] = {
            'token': access_token,
            'expires_at': datetime.now() + timedelta(seconds=3300)  # 留 5 分钟缓冲
        }

        return access_token
```

---

### 问题 3: 如何在前端管理 session_id?

**方案 1: 使用 sessionStorage (推荐用于匿名用户)**

```javascript
// 前端生成唯一 session_id
function getOrCreateSessionId() {
    let sessionId = sessionStorage.getItem('coze_session_id');
    if (!sessionId) {
        sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        sessionStorage.setItem('coze_session_id', sessionId);
    }
    return sessionId;
}

// 使用
const sessionId = getOrCreateSessionId();
```

**特点**:
- ✅ 关闭标签页后会话失效
- ✅ 新打开的标签页会创建新会话
- ✅ 适合匿名访问场景

**方案 2: 使用 localStorage (用于持久化会话)**

```javascript
function getUserSessionId() {
    let sessionId = localStorage.getItem('coze_session_id');
    if (!sessionId) {
        sessionId = 'user_' + getUserIdFromAuth();  // 从登录系统获取
        localStorage.setItem('coze_session_id', sessionId);
    }
    return sessionId;
}
```

**特点**:
- ✅ 关闭浏览器后会话保留
- ✅ 适合已登录用户场景
- ⚠️ 需要处理用户登出时的清理

---

### 问题 4: 如何验证会话隔离是否生效?

**测试脚本**:

```python
def test_session_isolation():
    """测试会话隔离功能"""

    # 用户 A 的第一轮对话
    response_a1 = chat_with_workflow(
        access_token=get_token("USER_A"),
        workflow_id="xxx",
        app_id="xxx",
        session_name="USER_A",
        user_message="你好,我叫张三,我25岁"
    )
    print(f"用户A第一轮: {response_a1}")

    # 用户 B 的第一轮对话
    response_b1 = chat_with_workflow(
        access_token=get_token("USER_B"),
        workflow_id="xxx",
        app_id="xxx",
        session_name="USER_B",
        user_message="你好,我叫李四,我是程序员"
    )
    print(f"用户B第一轮: {response_b1}")

    # 用户 A 的第二轮对话 - 测试上下文
    response_a2 = chat_with_workflow(
        access_token=get_token("USER_A"),
        workflow_id="xxx",
        app_id="xxx",
        session_name="USER_A",
        user_message="我叫什么名字?我多大?"
    )
    print(f"用户A第二轮: {response_a2}")

    # 验证
    if "张三" in response_a2 and "25" in response_a2:
        print("✅ 用户A上下文正确")
    else:
        print("❌ 用户A上下文错误")

    # 用户 A 问 B 的信息 - 测试隔离
    response_a3 = chat_with_workflow(
        access_token=get_token("USER_A"),
        workflow_id="xxx",
        app_id="xxx",
        session_name="USER_A",
        user_message="李四是谁?"
    )

    # 验证隔离
    if "程序员" not in response_a3:
        print("✅ 会话隔离成功 - 用户A不知道用户B的信息")
    else:
        print("❌ 会话隔离失败 - 用户A知道了用户B的信息")
```

---

## 完整示例代码

### 后端实现 (Python + FastAPI)

```python
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import httpx
import jwt
import time
import uuid
from datetime import datetime, timedelta

app = FastAPI()

# 配置
CLIENT_ID = "your_client_id"
PUBLIC_KEY_ID = "your_public_key_id"
PRIVATE_KEY = """-----BEGIN RSA PRIVATE KEY-----
...
-----END RSA PRIVATE KEY-----"""
WORKFLOW_ID = "your_workflow_id"
APP_ID = "your_app_id"
API_BASE = "https://api.coze.cn"

# Token 缓存
token_cache = {}

class ChatRequest(BaseModel):
    message: str
    user_id: str
    conversation_id: str = None

def create_jwt_token(session_name):
    """创建 JWT Token"""
    now = int(time.time())
    payload = {
        "iss": CLIENT_ID,
        "aud": "api.coze.cn",
        "iat": now,
        "exp": now + 3600,
        "jti": str(uuid.uuid4()),
        "session_name": session_name  # ✅ 会话隔离
    }
    headers = {
        "kid": PUBLIC_KEY_ID,
        "alg": "RS256",
        "typ": "JWT"
    }
    return jwt.encode(payload, PRIVATE_KEY, algorithm="RS256", headers=headers)

def get_access_token(session_name):
    """获取 Access Token (带缓存)"""
    # 检查缓存
    if session_name in token_cache:
        cached = token_cache[session_name]
        if cached['expires_at'] > datetime.now():
            return cached['token']

    # 生成新 Token
    jwt_token = create_jwt_token(session_name)

    response = httpx.post(
        f"{API_BASE}/api/permission/oauth2/token",
        json={
            "grant_type": "urn:ietf:params:oauth:grant-type:jwt-bearer",
            "assertion": jwt_token,
            "duration_seconds": 3600
        }
    )

    if response.status_code != 200:
        raise HTTPException(500, f"获取 Token 失败: {response.text}")

    access_token = response.json()["access_token"]

    # 缓存
    token_cache[session_name] = {
        'token': access_token,
        'expires_at': datetime.now() + timedelta(seconds=3300)
    }

    return access_token

@app.post("/api/chat")
async def chat(request: ChatRequest):
    """聊天接口"""
    session_name = request.user_id
    access_token = get_access_token(session_name)

    # ✅ 构建 payload (包含 session_name)
    payload = {
        "workflow_id": WORKFLOW_ID,
        "app_id": APP_ID,
        "session_name": session_name,  # ← 关键!
        "parameters": {
            "USER_INPUT": request.message
        },
        "additional_messages": [
            {
                "content": request.message,
                "content_type": "text",
                "role": "user",
                "type": "question"
            }
        ]
    }

    # 如果有 conversation_id,添加到 payload
    if request.conversation_id:
        payload["conversation_id"] = request.conversation_id

    # 调用 Coze API
    response = httpx.post(
        f"{API_BASE}/v1/workflows/chat",
        json=payload,
        headers={
            "Authorization": f"Bearer {access_token}",
            "Content-Type": "application/json"
        },
        timeout=30
    )

    if response.status_code != 200:
        raise HTTPException(500, f"API 调用失败: {response.text}")

    return response.json()
```

### 前端实现 (JavaScript)

```javascript
// 获取或创建 session_id
function getSessionId() {
    let sessionId = sessionStorage.getItem('coze_session_id');
    if (!sessionId) {
        sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        sessionStorage.setItem('coze_session_id', sessionId);
    }
    return sessionId;
}

// 发送消息
async function sendMessage(message) {
    const sessionId = getSessionId();

    const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({
            message: message,
            user_id: sessionId
        })
    });

    const data = await response.json();
    return data;
}

// 使用示例
sendMessage('你好').then(response => {
    console.log('AI回复:', response);
});
```

---

## 参考资料

- [Coze OAuth JWT 文档](https://www.coze.cn/docs/developer_guides/oauth_jwt)
- [Coze Workflow Chat API](https://www.coze.cn/docs/developer_guides/workflow_chat)
- [Coze 会话隔离官方说明](https://www.coze.cn/docs/developer_guides/session_isolation)
- [Chat SDK 接入指南](https://www.coze.cn/docs/developer_guides/chat_sdk)

---

**文档版本**: v1.0
**最后更新**: 2025-11-19
**作者**: 根据 Coze 官方文档整理

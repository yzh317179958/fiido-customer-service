# 应用对话流会话隔离问题总结与解决方案

## 问题背景

本项目使用的是 **应用对话流(Workflow)**,不是智能体(Bot)。在实现会话隔离时遇到以下问题:

### 测试现象
- 用户 A 和用户 B 使用不同的 `session_name`
- JWT Token 正确包含各自的 `session_name`
- API 请求 payload 也正确包含 `session_name`
- 但用户 A 仍然能"知道"用户 B 的信息(会话上下文混淆)

---

## 根本原因分析

根据官方反馈,对话流会话隔离失败的根本原因包括:

### 1. 静态会话绑定与使用错误
- 应用对话流需绑定独立的静态会话(每个用户一个会话)
- 但可能存在多个用户复用同一静态会话的情况,导致消息存储冲突

### 2. 长期记忆/知识库未按 session_name 隔离
- **长期记忆节点未启用「按会话隔离」**,导致不同用户记忆数据共享
- 知识库检索时未传入 `session_name` 作为筛选条件,全局数据泄露

### 3. 对话流的 Conversation 管理限制
- `/v1/conversations` API **不适用于 Workflow**
- 该 API 仅用于 Bot 类型的智能体
- 对于 Workflow,无法通过 API 创建独立的 conversation

---

## 代码层面已正确实现

### ✅ JWT Payload 包含 session_name

```python
# src/jwt_signer.py
payload = {
    "iss": client_id,
    "aud": "api.coze.com",
    "iat": now,
    "exp": now + 3600,
    "jti": str(uuid.uuid4()),
    "session_name": session_id  # ✅ JWT 中包含
}
```

### ✅ API 请求 Payload 包含 session_name

```python
# backend.py
payload = {
    "workflow_id": WORKFLOW_ID,
    "app_id": APP_ID,
    "session_name": session_id,  # ✅ API 中包含
    "parameters": {
        "USER_INPUT": request.message
    },
    "additional_messages": [...]
}
```

### ✅ 每个用户使用独立的 Token

```python
# Token 管理器按 session_name 缓存
access_token = token_manager.get_access_token(session_name=session_id)
```

**结论**: 代码层面的实现完全符合官方要求,问题不在代码。

---

## 解决方案

要实现完整的会话隔离,需要在 **Coze 平台配置** + **代码实现** 两方面同时进行。

### 方案 1: 配置工作流的长期记忆节点(推荐)

如果你的工作流使用了**长期记忆节点**,必须启用会话隔离:

#### 步骤:
1. 登录 Coze 平台
2. 进入工作流编辑页面
3. 找到"长期记忆"节点
4. 在节点配置中,启用 **"按会话隔离"** 选项
5. 保存并发布工作流

#### 效果:
- 不同 `session_name` 的用户将拥有独立的记忆存储
- 用户 A 的记忆不会被用户 B 看到

---

### 方案 2: 配置知识库的会话级筛选

如果工作流使用了**知识库检索**:

#### 步骤:
1. 在知识库节点配置中
2. 添加筛选条件: 使用 `session_name` 作为筛选字段
3. 确保知识库数据按用户分类存储

#### 效果:
- 知识库检索时只返回当前用户相关的数据
- 避免全局数据泄露

---

### 方案 3: 避免使用静态会话名称

在工作流配置中:

#### 步骤:
1. 检查工作流是否配置了固定的"会话名称"
2. 如果配置了,**删除或禁用**静态会话名称
3. 让系统使用 API 传入的 `session_name` 动态管理会话

#### 原因:
- 如果工作流绑定了静态会话名称(如 "default")
- 所有用户会共享这个静态会话
- API 传入的 `session_name` 会被忽略

---

### 方案 4: 使用 Bot 代替 Workflow(备选)

如果上述方案都无法解决:

#### 考虑切换到 Bot 模式:
- Bot 支持 `/v1/conversations` API
- 可以为每个用户创建独立的 conversation_id
- 会话隔离更彻底

#### 代码示例:

```python
# 1. 为每个用户创建独立的 conversation
conversation_id = create_conversation(access_token)
conversation_cache[session_id] = conversation_id

# 2. 使用 Bot Chat API (而不是 Workflow Chat API)
response = httpx.post(
    f"{api_base}/v3/chat",  # Bot API
    json={
        "bot_id": BOT_ID,
        "user_id": session_id,
        "conversation_id": conversation_id,  # ← 独立的 conversation
        "query": user_message,
        "stream": False
    },
    headers={"Authorization": f"Bearer {access_token}"}
)
```

---

## 当前代码状态

### ✅ 已实现
1. JWT 中包含 `session_name`
2. API Payload 中包含 `session_name`
3. 每个用户使用独立的 Access Token
4. Token 按 `session_name` 缓存和管理

### ⚠️ 已尝试但不可行
1. 创建独立的 Conversation ID
   - `/v1/conversations` API 对 Workflow 不可用
   - 代码已添加但会报错 4000

### ❌ 需要在 Coze 平台配置
1. 长期记忆节点的会话隔离设置
2. 知识库的会话级筛选
3. 静态会话名称的移除

---

## 下一步操作建议

### 立即检查:
1. **登录 Coze 平台** → 进入工作流编辑
2. **检查是否有长期记忆节点** → 启用"按会话隔离"
3. **检查是否有静态会话配置** → 移除固定的会话名称
4. **检查知识库节点** → 添加 session_name 筛选

### 验证步骤:
1. 修改配置后,重新发布工作流
2. 运行测试脚本: `python3 tests/test_session_name.py`
3. 观察用户 A 是否还能"知道"用户 B 的信息

### 如果仍然失败:
1. 考虑联系 Coze 官方技术支持
2. 提供工作流 ID 和详细日志
3. 询问 Workflow 的会话隔离最佳实践
4. 或考虑切换到 Bot 模式

---

## 技术限制说明

### Workflow vs Bot 的差异

| 特性 | Workflow (对话流) | Bot (智能体) |
|------|------------------|--------------|
| Conversation API | ❌ 不支持 | ✅ 支持 |
| 会话隔离方式 | session_name + 平台配置 | session_name + conversation_id |
| 长期记忆隔离 | 需要手动配置 | 自动隔离 |
| 知识库隔离 | 需要筛选配置 | 自动隔离 |
| 实现复杂度 | 高(需要平台配置) | 中(API 可控) |

### 我们的选择
- 当前使用: Workflow
- 原因: [你的业务原因]
- 限制: 会话隔离需要平台配置支持

---

## 参考资料

- [Coze Workflow Chat API](https://www.coze.com/docs/developer_guides/workflow_chat)
- [会话隔离官方说明](https://www.coze.com/docs/developer_guides/session_isolation)
- [长期记忆节点配置](https://www.coze.com/docs/guides/long_term_memory)

---

**文档创建时间**: 2025-11-19
**问题状态**: 待在 Coze 平台配置
**代码状态**: 已正确实现
